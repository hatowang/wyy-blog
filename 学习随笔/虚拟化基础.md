## 虚拟化

### CPU虚拟化
- 目标是GuestOS(vm中的os)里的指令能够正常执行，然后要保证性能和效率，尽可能的接近物理机。
- 方式：全虚拟化、半虚拟化、硬件辅助虚拟化
##### 1. CPU全虚拟化
- 定义：全虚拟化是指虚拟机模拟了完整的底层硬件，使得为原始硬件设计的操作系统或其他软件完全不用做任何修改就可以在虚拟机上运行。
- 实现：特权级压缩和二进制翻译（BT）技术 :正常情况下Ring0是特权敏感指令， 操作系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。虚拟化环境VMM占用VMM，系统无法运行在Ring0，系统降级占用Ring1，其他系统指令且必须运行在Ring0上的指令，通过二进制翻译技术捕获转译，让系统认为这些指令运行在Ring0级。

[CPU级别](picture/cou特权级别.png)

##### 2. CPU半虚拟化
- 定义：对虚拟机的操作系统进行内核改造，虚拟机有自己特殊指令，然后和vmm一起配合工作。
- 代表：xen
- 优点：性能很高，更接近物理机
- 缺点：无法模拟windows（内核闭源）

##### 3. 硬件辅助虚拟化
- 定义：对CPU指令做了改造，让CPU从根本上能支持虚拟化
- 技术：Intel(VT-x)，AMD(AMD-V)
- 查看是否支持虚拟化：

    intel: cat /proc/cpuinfo | grep vmx (Root模式，non-root模式)
    
    AMD:   cat /proc/cpuinfo | grep svm
- 有点：性能接近物理机
- 代表：kvm技术 


### 内存虚拟化
- 内存是宿主机提供的，GustOS属于宿主机的进程
- GustOS和宿主机使用的是相同的物理内存，组要做到相互不不影响
- 全虚拟、半虚拟、硬件辅助
- 物理内存划分（os中，物理内存会被划分为很多大小相同的连续部分）、块（划分出来的单位）、页（分页存储挂你，将用户作业的逻辑地址划分为一系列同等大小的部分）、页表(物理内存的块号和逻辑内存的页号对应表)

##### 1. MEM全虚拟化
- 影子页表技术（show page Table)：给虚拟机建立一个影子页表。影子页表以客户机的页表建立起来，通过vmm交给MMU（内存管理单元），将地址转化到物理内存上，影子页表随guestOS的页表更新而更新。

##### 2. MEM半虚拟化
- 页表写入法：GuestOS的页表注册到VMM,交给VMM更新和维护

##### 2. MEM硬件辅助虚拟化
- EPT(Extended Page Table,扩展页表)技术：直接在GuestOS的页表上增加EPT扩展页表，可以直接将内存地址转为宿主机的物理地址。

### IO虚拟化

- 硬件和网卡方面的虚拟化，在使用的时候和宿主机相互不影响，相互隔离
- I/O虚拟化的目的是让虚拟机访问到他们所需要的IO资源

##### 1. I/O全虚拟化
- 通过模拟IO设备来实现
- 模拟的设备在虚拟机看来是一组“真正的”设备
- 虚拟出来的设备与底层的硬件无关

##### 1. I/O半虚拟化
- 采用前端驱动加后端驱动架构
- I/O共享环采用生产者和消费者机制产生和发送IO请求

##### 2. I/O硬件辅助虚拟化

- I/o硬件辅助虚拟化就是让虚拟机可以直接使用物理设备
- 支持的有Intel的VT-d，AMD的IOMMU和PCI-SIG的IOV
- VT-d通过减少VMM参与管理I/O流量的需求，加速了数据传输，大大提升了性能   




